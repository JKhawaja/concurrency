\section{Introduction}

In this paper we would like to describe an algorithmic approach to avoiding undesirable behavior in systems that have multiple processes (threads) accessing a shared data structure.

There aready exist a plethora of approaches to managing access to a shared structure, of which we will make brief mention of only a few techiques. 

It might be good to review: \textit{locks}, \textit{fine-grained locking}, and \textit{combining trees}.

It is also important to specify what exactly we mean by \textit{undesirable behavior}. Essentially we are trying to avoid problems with inefficiency and inconsistency. Namely, we would like to avoid overwriting values that have already been written e.g. a counter being overwritten with the same value multiple times. And we would also like to avoid problems that are usually seen as a lack of linearization e.g. a value being overwritten with an out-of-date value. 

Of course, every access management implementation will require a degree of tradeoff. For example, are we allowed to read a value at any time or must we always guarantee that all writes for that value have been completed? We will not focus on tradeoff choices in this paper. We focus primarily on constructing (a rather basic) non-blocking and strictly consistent concurrency management algorithm. How a developer may choose to utilize the algorithm will depend on the developers personal choice of system requirements. But we do note that the algorithm will be rather flexible in varying the degree of consistency for concurrently accessing a structure.

We will also address the atomicity of operations and sequence of operations as defined internally to a thread.


\begin{con-def}[\textsc{Concurrent Data Structure}]
	\label{cds}

\end{con-def}